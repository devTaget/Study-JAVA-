삼항 연산자, if문, switch문의 비교
   삼항 연산자: 조건식이 1개 있을 경우 사용
   if문: 조건식에 비교(>, <, >=, <=) 연산자를 사용하거나, 여러 개의 조건식을 논리 연산자(&&, ||)로 연결할 때 사용
   switch문: 하나의 변수에 여러 개의 값이 담길 수 있고, 각 값이 같은 지를 비교할 때 사용
---------------------------------------------------------------------------------------------------
대입 연산자(복합 대입 연산자, 누적 연산자)
   +=, -=, /=, *=, %=, ...

   int money = 10000;
   //money = money - 1000;
   money -= 1000;
   System.out.print(돈);

   int data = 10;
   //data = data + 1;
   //data += 1;
   data++;
   System.out.println(data);

증감 연산자
   ++, --

   전위형 : 해당 라인부터 바로 적용
      ++data
   후위형 : 다음 라인부터 바로 적용
      data++

-------------------------------------------------------------------------------------------------
▶ 반복문

▷ for문   
   int i=0;  i<10;  i=i+1
   for(초기식; 조건식; 증감식){
      실행할 문장;
   }

   1. 초기식
   ------------
   2. 조건식
   3. 실행할 문장
   4. 증감식
   5. 조건식
   6. 실행할 문장
   7. 증감식
   ...
   

▷ while문
   while(조건식){
      실행할 문장;
   }


for문과 while문의 목적
   - for : 몇 번 반복할 지 알 때
   - while : 몇 번 반복할 지 모를 때

▷ do~while문

   do {
      실행할 문장;
   } while(조건식);

   무조건 한 번은 실행되어야 할 때 사용한다.
---------------------------------------------------------------------------------------------
기타 제어문
   break : 즉시 해당 중괄호 영역을 탈출한다.
      - if문 안에서 사용 시 if문을 탈출하지 않고 if문을 감싸고 있는 중괄호 영역을 탈출한다.

   continue : 즉시 다음 반복.
      - 아래의 코드를 실행하지 않기 위해서 사용한다.
---------------------------------------------------------------------------------------------
배열 : 저장공간의 나열

   1.
      변수를 여러 개 선언하면 이름도 여러 개 생긴다. 이 때 각 저장공간을 관리하기가 불편하다.
      따라서 n칸 배열을 한 번만 선언하면 저장공간도 n개 생기고, 이름도 한 개이기 때문에 관리하기 편하다.

   2.
      규칙성이 없는 값에 규칙성을 부여하기 위해서


배열의 선언
   자료형[] 배열명 = {값1, 값2, ...}; // 어떤 값을 넣을 지 알 때 사용
   자료형[] 배열명 = new 자료형[칸수]; // 어떤 값을 넣을 지는 모르나, 몇 칸 만들지는 알 때 사용
   자료형[] 배열명 = null; // 어떤 값을 넣을지도 모르고, 몇 칸 만들지도 모를 때 사용한다.
   배열명 = new 자료형[칸수];

   ※ new: Heap 메모리에 할당, 초기값으로 자동 초기화
   ※ null: 주소의 초기값, 어떤 주소를 넣을 지 모를 때 작성하는 초기값
   ※ 자바에서 배열은 항상 Heap(동적 메모리)에 할당되기 때문에 메모리 상으로는 동적배열만 존재한다.

배열의 구조
   int[] arData = {3, 5, 1, 2, 8};

   arData라는 이름의 저장공간은 한 개 만들어지며, 여기에는 한 개의 값만 담을 수 있다.
   5개의 값을 담기 위해서는 5칸이 필요하며, 이는 Heap 메모리에 할당된다. 5칸의 저장공간 중
   첫 번째 저장공간의 주소값이 arData 저장공간으로 들어가며, 다음 주소에 접근하기 위해서는
   + n을 한다. 예를 들어 arData + 2는 1이라는 값이 담긴 주소값이 되며,
   *(arData + 2)는 해당 주소에 가서 읽어온 1이라는 값이 된다. JAVA에서는 직접 주소에 접근하는
   연산자가 없기 때문에 위와 같은 식을 []로 치환하여 사용하며, arData[2]로 사용한다.
   각각의 방 번호는 index라고 부르며, 배열은 시작주소를 가지고 있기 때문에 인덱스 번호는 항상 0부터 시작된다.

length
   배열을 선언하면 length라는 상수가 선언되고, 해당 배열의 길이가 담긴다.
   배열명.length로 사용하게 된다.

배열의 사용
   int[] arData = new int[5]; // 선언
   arData[0] = 10; // 선언
   arData[0] + 9; // 사용
   System.out.println(arData); // 주소값
   arData[2] = arData[0] + arData[1]; // 선언, 사용
   System.out.println(arData[5]); // 오류
------------------------------------------------------------------------------------------------
2차원 배열 : 배열 안에 배열
   
   1차원 배열을 여러 개 선언할 때 관리하기 힘들기 때문에
   2차원 배열을 한 번 선언한다.
   
   ※ 2차원 배열부터는 메모리 낭비가 심하므로 선호하지 않는다.

2차원 배열 선언
   자료형[][] 배열명 = {{값1, 값2, 값3,...}, {값4, 값5, 값6,...}};
   자료형[][] 배열명 = new 자료형[행][열];
   자료형[][] 배열명 = null;


   int[][] arrData = new int[2][3];

   □   arrData      arrData.length(행의 길이)
   □□   arrData[행]   arrData[행].length(열의 길이)
     □□□ □□□   arrData[행][열]
--------------------------------------------------------------------------------


























